%!PS-Adobe-3.0
%%BoundingBox: 0 0 760 2600

% Choices what to selectively cut. From bottom up.
/print-bottom true def             % Bottom pane, holding drive-train
/print-bottom-drivetrain true def  % motor holder and bearing
/print-slide-rail-bottom true def  % The rails the sled is riding on.
/print-sled true def               % The sled moving the PCB along.
/print-slide-rail-top true def     % The rails the sled is riding under.
/print-sidepanels true def         % Side panels framing of the outer case.
/print-front-back true def         % Front and back parts of the case.
/print-toppanel true def           % The laser and rotating mirror mounted here.

/print-pcbframe false def  % Suggested to cut on thinner material (1mm acrylic)

/print-measures false def   % Show measurement lines and descriptions

% For testing while tweaking finger/slot output on your laser cutter.
% Typical tweak parameters are /acrylic-t, /do-reliefs, /relief-r, /slot-thick
/print-TEST-finger-slot false def

/mm { 72 25.4 div mul } bind def

/acrylic-t 3 mm def        % Material thickness.

% reliefs on inner edges for finger/slots.
/do-reliefs true def
/relief-r 0.15 mm def

/slot-thick acrylic-t def  % slot thickness for snug fit.

/screw-r 3.1 mm 2 div def
/rod-r 4.7 mm 2 div def
/finger-len 20 mm def
/connect-screw-len 4.5 mm def

/pcb-w-mm 100 def
/pcb-h-mm 160 def

/pcb-w pcb-w-mm mm 2 mm add def
/pcb-h pcb-h-mm mm 2 mm add def

/bed-w pcb-w acrylic-t 2 mul add 10 mm add def    % rail + 5 mm extra on each edge
/bed-h pcb-h 10 mm add def

% derived from above.
/bed-pcb-off-w bed-w pcb-w sub 2 div def
/bed-pcb-off-h bed-h pcb-h sub 2 div def

/bed-slide-high-bottom 29 mm def
/bed-slide-high-top 8 mm def
/slide-hole-count 4 def

% how high the front part should be. Essentially it should end shy below
% where the bed tray emerges.
/front-cover-high bed-slide-high-bottom 1 mm sub def

/drive-train-fingers 11 mm def   % finger distance for drive train on sled
/stepper-len 36 mm def
/stepper-height 28.2 mm def       % nema11
/stepper-mount-screw 11.5 mm def  % screw distance measured from center
/stepper-screw-dia 2.5 mm def     % M2.5 for nema11
/stepper-center-plate-dia 22.5 mm def

/acme-dia 5 mm def            % acme screw diameter

/drive-mount-pos stepper-len def  % stepper mount position seen from back
/drive-screw-start 35 mm def      % axle to where acme screw starts
/bearing-mount-pos
    stepper-len drive-screw-start add  % starting from here
    pcb-h add                          % .. the amount we need to move
    acrylic-t add                      % space for drive-train holder
    def  % acme bearing

% we are placing the switches as close as possible to the center of the
% drive train to not have too much axial force (the microswitches in question
% use a little force). Otherwise the corner would of course be nice.
/end-switch-offset 0.30 bed-w mul def  % from center
/end-switch-thick 8 mm def             % thickness of switch
/end-switch-from-back-of-sled drive-mount-pos end-switch-thick add acrylic-t add def

% the corresponding assembly on the sled
/bed-drive-screw-w acrylic-t def      % distance between driving holders
/bed-drive-screw-r 10.6 2 div mm def  % outer radius of nut driving the thing.

/bed-drive-wobble 0.5 mm def  % amount of 'wobble' we should give the drive screw
/bed-drive-pos stepper-len drive-screw-start add def  % where the drive position relative from back.
/bed-drive-screw-top
     bed-slide-high-bottom stepper-height sub  % amount hovering about stepper
     stepper-height 2 div add
     def
/bed-drive-w bed-w 2 div def
/bed-drive-h bed-drive-screw-top bed-drive-screw-r add 2 mm add def

% TODO: calculate laser slot distance from angle, pcb-w, laser height etc.
/laser-slot-distance 160 mm def
/laser-slot-h 10 mm def
/laser-slot-w pcb-w 2 mm add def

% Hsync diffusor
/hsync-len laser-slot-h def
/hsync-w 2 mm def

/rot-mirror-high 33 mm 2 div def  % center of the laser
/rot-mirror-w 44 mm def
/rot-mirror-h 60 mm def
/rot-mirror-diameter 30 mm def

% The down mirror is elevated above the top plate, so we need the acrylic
% thickness to be on the same level as the rot mirror that is mounted on
% the top plate.
/down-mirror-high rot-mirror-high acrylic-t add def
/down-mirror-w 10 mm def
/down-mirror-t 4.5 mm def

% Given that we cover 60 degrees, we cover 2 * sin(30) times radius in
% horizontal direction, i.e. radius == pcb-w. We want to use a little less of
% the range to have space for synchronization.
/arc-radius pcb-w 20 mm add def

% actually, we should calculate the laser slot from the mirror center which
% should be placed as much back as we want. But for version #1, we already
% have set up the laser-slot-distance and the grooves and fingers, so let's go with
% that first.
/mirror-center-mount-from-slot
    arc-radius rot-mirror-high sub bed-slide-high-top sub
    rot-mirror-diameter add def

% We want to be at least half pcb sled longer so that we are supported
% at center of gravity.
/inner-device-len laser-slot-distance bed-h 2 div add def
/inner-device-high bed-slide-high-bottom bed-slide-high-top add acrylic-t add def

/mirror-holder-width 20 mm def  % width of the 45 degree down mirror holder
/mirror-holder-r mirror-holder-width 2 div def
/mirror-holder-high down-mirror-high mirror-holder-r add def

% -- variables to place properly between cuts
% distance between different cuts
/cut-dist print-measures { 6 mm } { 1 mm } ifelse def
/side-cut-distance inner-device-high 2 mul mirror-holder-high add cut-dist add acrylic-t add 35 mm add def

% Linewidth doesn't do anything to the DXF output, it just makes it easier
% to manually inspect in the PostScript viewer.
1 setlinewidth


% Like currentpoint but returns a boolean to describe if there was a point.
% Apparantly, PostScript does not have a predicate to ask for a current path,
% so we have to tap into the error message.
% currentpoint? x y true   % if there is a current point
% currentpoint? false      % if there isn't
/currentpoint? {
    2 dict begin
      /has-currentpoint true def
      /old-handler errordict /nocurrentpoint get def
      errordict /nocurrentpoint { pop /has-currentpoint false def} put
      currentpoint
      has-currentpoint
      errordict /nocurrentpoint currentdict /old-handler get put
    end
} def

/-gsave /gsave load def
/gsave {
    currentpoint? {
	% Ideally, we never reach this, but all paths are properly stroke'd
	% when gsave is called. But it is hard to find mis-uses in the
	% stack-trace gs provides. So just do the right thing and stroke
	% here to repair the situation.
	% (also, perfectly benign to have something with no path just a point)
	% The following will help debug it
	%-gsave /Helvetica findfont 10 scalefont setfont (<- Here not properly stroked) show grestore
	stroke
        -gsave
	moveto
    } {
	-gsave
    } ifelse
} def

%%-- measureline.ps

% Measure-line features. It is a little hard to get things PostScript files
% included depending on context. So we include it here manually.
/measure-fontsize 5 mm def
/measure-font /Helvetica-Bold findfont measure-fontsize scalefont def
/measure-desc-font /Helvetica findfont 4 mm scalefont def
/measure-dict << >> def
/measure-col { 0.7 0.7 0.7 setrgbcolor } def

% (desc) measure-offset dx dy
/measure-to {
    2 copy atan rotate
    5 dict begin
    dup mul exch dup mul add sqrt /len exch def
    /offset exch def
    /desc-text exch def
    /display-len len 72 div 25.4 mul 100 mul round 100 div def
    /arrow-len 3 mm def
    /arrow-w 1 mm def
    /measure-unit () def   % mm took too much space

    %0 offset moveto len offset lineto

    % Without offset, add at least a little measurement stub.
    offset 0 eq {
      0 offset -0.5 mm add moveto   0 offset 0.5 mm add lineto
      len offset -0.5 mm add moveto len offset 0.5 mm add lineto
    } if

    % Arrow between lines
    0 offset moveto arrow-len offset arrow-w add lineto
    0 offset moveto arrow-len offset arrow-w neg add lineto

    len offset moveto len arrow-len sub offset arrow-w add lineto
    len offset moveto len arrow-len sub offset arrow-w neg add lineto

    0 0 moveto 0 offset lineto
    len 0 moveto len offset lineto

    display-len (         ) cvs
    dup stringwidth pop measure-unit stringwidth pop add 2 div /text-w-half exch def

    0 offset moveto len 2 div text-w-half sub 0.5 mm sub offset lineto

    len 2 div text-w-half sub         % x
    offset measure-fontsize 3 div sub moveto show measure-unit show
    len 2 div text-w-half add 0.5 mm add offset moveto
    len offset lineto

    measure-desc-font setfont
    len 2 div desc-text stringwidth pop 2 div sub offset measure-fontsize sub moveto
    desc-text show
    end
    stroke
} def

% (desc) measure-offset x1 y1 x2 y2
/measure-line {
    4 2 roll
    2 copy translate
    % 2=20 20 1=20 10
    3 -1 roll exch  % 20 20 10 20
    sub        % 20 20 dx
    3 1 roll sub % dx dy
    measure-to
} def

% pos-x pos-y
/measure-A {
    % array stores [(desc) line-offset x1 y1 x2 y2]
    userdict /current-measure [() 0  0 0  0 0] put
    current-measure 2 3 index put   % x
    current-measure 3 2 index put   % y
} def
/current-measure-A {
    currentpoint measure-A pop pop
} def

% pos-x pos-y [optional-array-with-offset]
/measure-B {
    dup type (arraytype) eq {
	dup 0 get   % get offset
	current-measure 1 3 -1 roll put
	dup length 1 gt {  % get description string if available
	    dup 1 get
 	    current-measure 0 3 -1 roll put
	} if
	pop
    } if
    current-measure 4 3 index put   % x
    current-measure 5 2 index put   % y
    measure-dict measure-dict length current-measure put  % now append at end.
} def
/current-measure-B {
    count 0 gt {
      dup type (arraytype) eq {
	dup 0 get   % get offset
	current-measure 1 3 -1 roll put
	dup length 1 gt {  % get description string if available
	    dup 1 get
 	    current-measure 0 3 -1 roll put
	} if
	pop
      } if
    } if
    currentpoint measure-B pop pop
} def

/clear-measures {
    userdict /measure-dict << >> put
} def

/flush-measures {
    stroke   % Flush whatever is to be drawn, otherwise ghostscript does it twice
    print-measures {
      gsave
      0.5 setlinewidth
      measure-col
      measure-font setfont
      measure-dict {
        aload pop   % put array content on stack. Get rid of array
        gsave measure-line grestore
        pop         % get rid of dict key.
      } forall
      grestore
    } if
    clear-measures
} def

%%-- measureline.ps

/inner-cut { 1 0 0 setrgbcolor } def
/outer-cut { 0 0 0 setrgbcolor } def
/engraving-cut { 0 1 0 setrgbcolor } def

% (description) x y
/describe {
    print-measures {
      -gsave
      /Helvetica findfont 8 mm scalefont setfont
      measure-col
      moveto
      show
      grestore
    } if
} def

% r
/currentpoint-circle {
    1 dict begin
    /crr exch def
    currentpoint
    crr 0 rmoveto
    crr 0 360 arc
    crr neg 0 rmoveto
    end
} def

% x y r
/circle {
    3 1 roll moveto currentpoint-circle
} def

% Given a direction in delta coordinats and a length, return the new
% coordinates where that vector points to.
% dir_x dir_y length  -> dx dy (relative position)
/colinear {
	5 dict begin
       /thick exch  def
       /dy exch def
       /dx exch def
       /len dx dx mul dy dy mul add sqrt def
       /fraction thick len div def  % fraction of amount that is perpendicular
       dx fraction mul dy fraction mul
       end
} def

% Similar to colinear, but yields the coordinates of the normal of the given
% length, so perpendicular to the original coordinates in delta.
% dir_x dir_y length  -> dx dy (relative position)
/perpendicular {
	5 dict begin
       /thick exch  def
       /dy exch def
       /dx exch def
       /len dx dx mul dy dy mul add sqrt def
       /fraction thick len div def  % fraction of amount that is perpendicular
       dy fraction mul neg dx fraction mul
       end
} def

% dx dy thick
/orth-segment {
	4 dict begin
       /thick exch  def
       /is-outer thick 0 gt def
       /dy exch def
       /dx exch def
       dx dy thick perpendicular rlineto is-outer { relief-here } if
       dx dy rlineto                     is-outer { relief-here } if
       dx dy thick neg perpendicular rlineto
       end
} def

% dx dy  % create a hole half way down the dx dy
/connect-hole {
    2 dict begin
    /sdy exch def
    /sdx exch def
    sdx 2 div sdy 2 div rmoveto
    sdx sdy thick 2 div perpendicular rmoveto
    currentpoint 1 mm circle
    sdx sdy thick 2 div neg perpendicular rmoveto
    sdx 2 div neg sdy 2 div neg rmoveto
    end
} def

% dx dy  % create a tslot half way down the dx dy
/connect-t-slot {
  3 dict begin
  /sdy exch def
  /sdx exch def
  /ff finger-len 2 mm sub finger-len div 2 div def
  sdx ff mul sdy ff mul rmoveto
  sdx sdy -0.5 mm perpendicular rmoveto
  sdx sdy connect-screw-len perpendicular rlineto
  sdx sdy -1 mm colinear rlineto
  relief-here
  sdx sdy 1.6 mm perpendicular rlineto
  sdx sdy 1 mm colinear rlineto
  sdx sdy connect-screw-len 2 div perpendicular rlineto
  sdx sdy 2 mm colinear rlineto
  sdx sdy connect-screw-len 2 div neg perpendicular rlineto
  sdx sdy 1 mm colinear rlineto
  sdx sdy -1.6 mm perpendicular rlineto
  currentpoint stroke moveto
  relief-here
  sdx sdy -1 mm colinear rlineto
  sdx sdy connect-screw-len neg perpendicular rlineto
  currentpoint stroke moveto
  % go back
  sdx sdy 0.5 mm perpendicular rmoveto
  sdx sdy 2 mm neg colinear rmoveto
  sdx ff mul neg sdy ff mul neg rmoveto
  end
} def

% x y thick
/finger-groove-rlineto {
    12 dict begin
    /thick exch def
    /is-inner thick 0 lt def
    /dy exch def
    /dx exch def
    /len dx dx mul dy dy mul add sqrt def
    /factor acrylic-t len div def  % perpendicular thing.
    /segments
         len finger-len sub  % we want one finger len at the end
	 finger-len 2 mul    % number of low and up segments
	 div floor cvi def
    /extra-fraction len finger-len sub
         segments finger-len 2 mul mul sub len div 2 div def
    dx extra-fraction mul dy extra-fraction mul rlineto
    /sdx dx finger-len len div mul def
    /sdy dy finger-len len div mul def
    1 1 segments {
	pop
	sdx sdy rlineto            is-inner { relief-here } if
	sdx sdy thick orth-segment is-inner { relief-here } if
    } for
    sdx sdy rlineto  % one extra bottom segment.
    dx extra-fraction mul dy extra-fraction mul rlineto
    end
} def

% x y thick do_hole { 0, 1, 2 }
/hole-slot-rlineto {
    12 dict begin
    /do-hole exch def
    /thick exch def
    /dy exch def
    /dx exch def
    /len dx dx mul dy dy mul add sqrt def
    /factor acrylic-t len div def  % perpendicular thing.
    /segments
         len finger-len sub  % we want one finger len at the end
	 finger-len 2 mul    % number of low and up segments
	 div floor cvi def
    /extra-fraction len finger-len sub
         segments finger-len 2 mul mul sub len div 2 div def
    dx extra-fraction mul dy extra-fraction mul rmoveto
    /sdx dx finger-len len div mul def
    /sdy dy finger-len len div mul def
    1 1 segments {
	pop
	do-hole 1 eq {  % hole
	    sdx sdy connect-hole
	} if
	do-hole 2 eq {  % t-slot
	    sdx sdy connect-t-slot
	} if
	sdx sdy rmoveto
	sdx sdy rmoveto
    } for

    do-hole 1 eq {  % hole
      sdx sdy connect-hole
    } if
    do-hole 2 eq {  % t-slot
      sdx sdy connect-t-slot
    } if
    sdx sdy rmoveto
    dx extra-fraction mul dy extra-fraction mul rmoveto
    end
} def

% dx dy
/t-slot-rlineto {
    acrylic-t neg 2 hole-slot-rlineto
} def
/hole-rlineto {
    acrylic-t neg 1 hole-slot-rlineto
} def

% dx dy
/finger-rlineto {
    2 copy t-slot-rlineto 2 copy neg exch neg exch rmoveto
    acrylic-t neg finger-groove-rlineto
} def

/groove-rlineto {
    2 dict begin
    /dy exch def
    /dx exch def
    dx dy hole-rlineto dx neg dy neg rmoveto
    dx dy acrylic-t neg perpendicular rlineto
    dx dy acrylic-t finger-groove-rlineto
    dx dy acrylic-t perpendicular rlineto
    end
} def

/finger-rlineto-noscrew {
    acrylic-t neg finger-groove-rlineto
} def

/groove-rlineto-noscrew {
    2 dict begin
    /dy exch def
    /dx exch def
    dx dy acrylic-t neg perpendicular rlineto
    dx dy acrylic-t finger-groove-rlineto
    dx dy acrylic-t perpendicular rlineto
    end
} def

% Given an absolute target coordinate, converts that to a relative call.
% xt yt proc
/lineto-to-rlineto-proc {  % need: (xt - x) (yt - y)
    3 1 roll
    currentpoint  % xt yt x y
    3 -1 roll exch sub  % xt yt x y -> xt x y yt -> xt x yt y -> xt x (yt - y)
    3 1 roll sub  % dy dx
    exch
    3 -1 roll exec
} def

% Same finger/groove commands as above, but with lineto
/finger-lineto { { finger-rlineto } lineto-to-rlineto-proc } def
/groove-lineto {  { groove-rlineto } lineto-to-rlineto-proc } def
/finger-lineto-noscrew {  { finger-rlineto-noscrew } lineto-to-rlineto-proc } def
/groove-lineto-noscrew {  { groove-rlineto-noscrew } lineto-to-rlineto-proc } def

% dx dy
/slot-rlineto {
    gsave
    inner-cut   % inside kerf correction.
    9 dict begin
    /dy exch def
    /dx exch def
    /len dx dx mul dy dy mul add sqrt def
    /segments
         len finger-len sub  % we want one finger len at the end
	 finger-len 2 mul    % number of low and up segments
	 div floor cvi def
    /extra-fraction len finger-len sub
         segments finger-len 2 mul mul sub len div 2 div def

    currentpoint translate dy dx atan rotate

    /dx len def
    /dy 0 def
    dx extra-fraction mul dy extra-fraction mul rmoveto
    /sdx dx finger-len len div mul def
    /sdy dy finger-len len div mul def
    1 1 segments {
	pop
	sdx sdy rmoveto
	currentpoint
	sdx slot-thick relief-box
	moveto sdx 0 rmoveto
    } for
    stroke
    print-measures { measure-col 0 0 moveto len 0 lineto stroke } if
    end
    grestore
} def

/slot-lineto {  % need: (xt - x) (yt - y)
    currentpoint  % xt yt x y
    3 -1 roll exch sub  % xt yt x y -> xt x y yt -> xt x yt y -> xt x (yt - y)
    3 1 roll sub  % dy dx
    exch
    slot-rlineto
} def

% r is the outer radius.
% n r
/n-polygon {
    gsave
    currentpoint translate
    3 dict begin
    /r exch def
    /n exch def
    /angle 360 n div def
    r 0 moveto
    1 1 n {
	dup
	angle mul cos r mul
	exch
	angle mul sin r mul
	lineto
    } for
    closepath stroke
    end
    grestore
} def

/end-switch {
    currentpoint
    0 0 1 mul rmoveto 0.6 mm currentpoint-circle
    0 5.02 mm rmoveto 0.6 mm currentpoint-circle
    0 5.02 mm rmoveto 0.6 mm currentpoint-circle stroke
    %moveto currentpoint
    %engraving-cut -2.6 mm -2.6 mm rmoveto 5.2 mm 2.54 mm 6 mul box stroke
    %outer-cut
    moveto
} def

/hsync-slot {
    0 hsync-w 2 div neg rmoveto
    hsync-len hsync-w box
} def

% x y
/photo-diode-cutout {
    inner-cut
    moveto
    0 2.5 mm rlineto
    -3.7 mm 0 rlineto
    0 0.5 mm rlineto
    -1.1 mm 0 rlineto

    0 -1.4 mm rlineto  % lead cutout
    -4 mm 0 rlineto
    0 -3.2 mm rlineto
    4 mm 0 rlineto
    0 -1.4 mm rlineto

    1.1 mm 0 rlineto
    0 0.5 mm rlineto
    3.7 mm 0 rlineto
    closepath
    currentpoint
    stroke
    moveto hsync-slot stroke
    outer-cut
} def

/screw {
    screw-r circle
} def

% Initially, we had rods through the hole width, now just simple
% screws.
/rod {
    screw-r circle
} def

/relief-here {
    do-reliefs { relief-r currentpoint-circle } if
} def

% make a box at current position with given width/height
% w h -> -
/box {
  2 dict begin
  /h exch def
  /w exch def

  w 0 rlineto
  0 h rlineto
  w neg 0 rlineto
  0 h neg rlineto
  closepath stroke
  end
} def

% Like box, but just take the measurements from the stack without drawing
% the box.
% w h -> w h
/measure-box {
  2 dict begin
  /h 1 index def
  /w 2 index def

  current-measure-A currentpoint exch w add exch [-3 mm] measure-B pop pop
  current-measure-A currentpoint h add [3 mm] measure-B pop pop
  end
} def

% like box, but with corner reliefs.
/relief-box {
  2 dict begin
  /h exch def
  /w exch def

  w 0 rlineto      relief-here
  0 h rlineto      relief-here
  w neg 0 rlineto  relief-here
  0 h neg rlineto  relief-here
  closepath stroke
  end
} def

% w h radius
/rounded-corner-box {
   3 dict begin
   /radius exch def
   /height exch def
   /width exch def

   currentpoint
   stroke   % need to flush state before gsave/grestore
   gsave
   translate
   0 radius add 0 moveto
   width radius sub 0 lineto
   width radius sub 0 radius add radius -90 0 arc

   width height radius sub lineto
   width radius sub height radius sub radius 0 90 arc

   0 radius add height lineto
   0 radius add height radius sub radius 90 180 arc

   0 0 radius add lineto
   0 radius add 0 radius add radius 180 270 arc
   closepath stroke
   grestore
   end
} def

% Boolean if outline should be printed
% bool x y
/rot-mirror-footprint {
    stroke
    gsave
    translate
    0 0 moveto
    currentpoint 7 mm circle
    41.6 mm 2 div 40 mm screw
    41.6 mm 2 div neg 40 mm screw
    41.6 mm 2 div -18.5 mm screw
    41.6 mm 2 div neg -18.5 mm screw
    stroke

    48 mm 2 div neg -24 mm translate

    % should we print the outline ?
    { 0 0 moveto 48 mm 68 mm box  } if % cuts the outer of the mirror

    48 mm 15 mm sub 2 div 0 moveto 15 mm 5 mm box
    stroke
    grestore
} def

% (text)
/center-show {
    dup stringwidth pop 2 div neg 0 rmoveto
    show
} def

% height screw-r
/slide-holes {
    2 dict begin
    /sr exch def
    /center-height exch 2 div def
    inner-device-len slide-hole-count div 2 div
    inner-device-len slide-hole-count div
    inner-device-len {
	center-height sr circle
    } for
    stroke
    end
} def

%---- end help procedures, start parts.

/part-toppanel {
    (Toppanel) 30 mm 5 mm describe
    /ldgraphy-font-size 22 mm laser-slot-w mul 104 mm div def

    % bottom area
    newpath
    0 0 moveto
    current-measure-A

    % up to mirror slot
    laser-slot-distance mirror-holder-r sub 0 finger-lineto-noscrew

    % mirror slot width
    mirror-holder-width 0 rlineto

    % to the end on the right.
    inner-device-len 0 finger-lineto-noscrew

    [-6 mm (inner-device-len)] current-measure-B

    % up. Curved or with circles.
    true {
       3 dict begin
       /distance-from-end
           inner-device-len
	   laser-slot-distance sub
	   laser-slot-h 2 div sub
	   ldgraphy-font-size sub % TODO: remove when text placed differently
	   def
       /ease-in-fraction 0.2 def
       /center-pull 1.1 def

       inner-device-len distance-from-end sub bed-w 2 div measure-A pop pop
       inner-device-len bed-w 2 div measure-B pop pop

       inner-device-len bed-w ease-in-fraction mul % control #1
       inner-device-len distance-from-end sub bed-w center-pull bed-w mul sub %#2
       inner-device-len distance-from-end sub bed-w 2 div  % center
       curveto

       inner-device-len distance-from-end sub bed-w center-pull mul % control #1
       inner-device-len bed-w 1 ease-in-fraction sub mul            % control #2
       inner-device-len bed-w
       curveto
       end
    } {
       1 dict begin
       /ease-in-r bed-w 10 div def
       inner-device-len ease-in-r sub 0 ease-in-r 0 90 arc
       inner-device-len ease-in-r sub          % center: on right edge
       bed-w 2 div               % .. in the middle
       bed-w 2 div ease-in-r sub     % radius a bit smaller. Will add a line
       270 90 arcn
       inner-device-len ease-in-r sub bed-w ease-in-r 270 360 arc
       end
    } ifelse

    laser-slot-distance mirror-holder-r add bed-w finger-lineto-noscrew
    mirror-holder-width neg 0 rlineto

    0 bed-w finger-lineto-noscrew
    0 0 finger-lineto-noscrew
    stroke

    % mounting holes for rotating mirror
    false  % do not cut outline
    laser-slot-distance mirror-center-mount-from-slot sub
    bed-w 2 div
        rot-mirror-footprint stroke

    % Wire hole for polygon mirror
    laser-slot-distance mirror-center-mount-from-slot sub 5 mm sub
    bed-w 12 mm sub moveto
    12 mm 5 mm 2 mm rounded-corner-box stroke

    % laser wires
    18 mm 36 mm 3 mm circle

    % Holes to mount the laser. Two holes in 20 mm distance
    35 mm 17 mm screw
    55 mm 17 mm screw stroke

    % hsync photo diode
    laser-slot-distance laser-slot-h 2 div sub
    bed-w bed-w laser-slot-w sub 2 div sub 1.5 hsync-w mul add
    photo-diode-cutout

    % Laser slot
    laser-slot-distance laser-slot-h 2 div sub bed-w laser-slot-w sub 2 div moveto
    laser-slot-h laser-slot-w measure-box 3 mm rounded-corner-box

    gsave
      % LDGraphy text. Right now in front of the slot, but should be placed
      % on a panel covering the front part (not there yet)
      engraving-cut
      laser-slot-distance laser-slot-h 2 div add  % right of laser slot
      bed-w 2 div moveto
      90 rotate
      /Courier findfont ldgraphy-font-size scalefont setfont
      0 ldgraphy-font-size 0.8 mul neg rmoveto
      gsave (LDGraphy) center-show grestore
   grestore
   flush-measures
} def

/part-sidepanel {
  newpath
   % bottom part
   (Sidepanel) 35 mm 8 mm describe
   0 0 moveto current-measure-A
   inner-device-len 0 lineto [6 mm (inner-device-len)] current-measure-B

   % up right side (back)
   current-measure-A
   1 dict begin
      /finger-len 12 mm def
     inner-device-len inner-device-high down-mirror-high add mirror-holder-r add acrylic-t sub groove-lineto
     [-8 mm] current-measure-B
   end

    inner-device-len laser-slot-distance sub
    inner-device-high down-mirror-high add mirror-holder-r add acrylic-t sub groove-lineto

    % Notch for mirror
    inner-device-len laser-slot-distance sub
    inner-device-high down-mirror-high add mirror-holder-r 90 180 arc

    % end of mirror holder, down to top panel again.
    inner-device-len laser-slot-distance sub mirror-holder-r sub inner-device-high lineto

    % towards the front
    0 inner-device-high groove-lineto-noscrew

   % down left side (front)
   current-measure-A
   1 dict begin
      /finger-len 9 mm def
      0 inner-device-high inner-device-high front-cover-high sub sub lineto
      0 0 groove-lineto
      [-6 mm] current-measure-B
    end
    stroke

    gsave
      inner-device-len laser-slot-distance sub  % we go from the back
      inner-device-high down-mirror-high add translate
      45 rotate
      down-mirror-w 2 div neg down-mirror-t 2 div neg moveto down-mirror-w down-mirror-t box
      stroke
   grestore

   bed-slide-high-bottom screw-r slide-holes
   gsave 0 bed-slide-high-bottom 3 mm add translate
   bed-slide-high-top screw-r slide-holes grestore

   % slots to hold top-panel
   inner-device-len laser-slot-distance sub mirror-holder-r add
   inner-device-high moveto
   inner-device-len inner-device-high slot-lineto

   inner-device-len inner-device-high measure-A pop pop
   inner-device-len 0 [-6 mm (inner-device-high    )] measure-B pop pop
} def

/part-slide-rail-bottom {
    0 acrylic-t translate
    1 dict begin
    /finger-len 15 mm def
    % We make the top part with rounded corners, so that it is
    % easier to slide on the top-case on the bottom base.
    0 0 moveto
    inner-device-len 0 finger-rlineto-noscrew
    inner-device-len bed-slide-high-bottom   % towards top
    0 bed-slide-high-bottom                  % towards left
    5 mm arct   % rounded corner
    0 bed-slide-high-bottom
    0 0
    5 mm arct
    0 0 lineto
    stroke

    % see /subpart-drivetrain-base for corresponding fingers
    /finger-len 5 mm def
    drive-mount-pos stepper-height moveto
    0 stepper-height neg slot-rlineto stroke

    % mouting for bearing
    bearing-mount-pos stepper-height moveto
    0 stepper-height neg slot-rlineto stroke
    end

    bed-slide-high-bottom screw-r slide-holes stroke
} def

/part-slide-rail-top {
    0 0 moveto inner-device-len bed-slide-high-top box
    bed-slide-high-top screw-r slide-holes
    stroke
} def

/part-back {
   (Back) 30 mm 5 mm describe
   newpath
   0 0 moveto
   bed-w 0 lineto

   1 dict begin
      /finger-len 12 mm def
      current-measure-A
      bed-w inner-device-high down-mirror-high add mirror-holder-r add acrylic-t sub finger-lineto   % up
      [-6 mm] current-measure-B
      bed-w neg 0 rlineto  % flat back for now.
      0 0 finger-lineto   % down
   end
   stroke

   % Top-panel matching.
   0 inner-device-high moveto current-measure-A
   bed-w 0 slot-rlineto stroke
   0 0 [20 mm (inner-device-high)] measure-B pop pop
   flush-measures
} def

/part-front {
   (Front) 30 mm 5 mm describe
   newpath
   0 0 moveto current-measure-A
   bed-w 0 lineto [-3 mm] current-measure-B

   current-measure-A
   1 dict begin
      /finger-len 9 mm def
      bed-w front-cover-high finger-lineto   % up
      [-6 mm] current-measure-B
   end

   bed-w neg 0 rlineto       % top accross

   1 dict begin
      /finger-len 9 mm def
     0 0 finger-lineto   % down
   end

   stroke
   flush-measures
} def

/part-pcbframe {
  (PCB Frame) 30 mm 20 mm describe
  % Frame to place PCB in.
  gsave
   % Outer frame
   acrylic-t 0 moveto bed-w acrylic-t 2 mul sub bed-h box

   % Inner frame
   bed-pcb-off-w bed-pcb-off-h translate
   0 0 moveto pcb-w pcb-h box

   0 0 measure-A pop pop
   0 pcb-h [-6 mm (pcb-h)] measure-B pop pop
   0 0 measure-A pop pop
   pcb-w 0 [10 mm (pcb-w)] measure-B pop pop
   flush-measures

   % Corner reliefs
   0 0 0.8 mm circle
   pcb-w 0 0.8 mm circle
   0 pcb-h 0.8 mm circle
   pcb-w pcb-h 0.8 mm circle
   stroke

   engraving-cut
   pcb-w 0 translate  % bottom left corner as origin for measurements
   /Courier findfont 2.5 mm scalefont setfont
   0 1 pcb-w-mm {
       1 dict begin
       /i exch def
       i mm neg 1 mm moveto
       i 5 mod 0 eq { i 10 mod 0 eq { -7 mm } { -4.5 mm } ifelse } { -3 mm } ifelse 0 exch rlineto stroke
       i 10 mod 0 eq {
	   gsave
           i mm neg 0.5 mm sub -4.5 mm translate 90 rotate
	   0 0 moveto
	   i 10 div cvi 5 string cvs show
	   grestore
       } if
      end
   } for
   0 1 pcb-h-mm {
       1 dict begin
       /i exch def
       i mm -1 mm exch moveto
       i 5 mod 0 eq { i 10 mod 0 eq { 7 mm } { 4.5 mm } ifelse } { 3 mm } ifelse 0 rlineto stroke
       i 10 mod 0 eq {
	   gsave
           i mm 0.5 mm add 4.5 mm exch translate 90 rotate
	   0 0 moveto
	   i 10 div cvi 5 string cvs show
	   grestore
       } if
       end
   } for
  grestore
} def

/subpart-drive-holder {
  gsave
  0 0 moveto
  bed-drive-h 0 rlineto
  current-measure-A
  0 bed-drive-w rlineto
  [-3 mm] current-measure-B
  bed-drive-h neg 0 rlineto
  0 bed-drive-w neg finger-rlineto-noscrew
  stroke

  bed-drive-screw-top bed-drive-w 2 div translate
  1 dict begin
  /nut-r bed-drive-screw-r bed-drive-wobble add 0.5 mm add def
  0 0 nut-r circle stroke
  0 nut-r neg moveto
  nut-r 1 mm add nut-r 2 mul box stroke
  end
  grestore
} def

/part-sled {
  (Sled) 90 mm 60 mm describe
  2 dict begin
  0 0 moveto bed-h bed-w 3 mm rounded-corner-box  % the sled
  stroke

  0 0 measure-A pop pop
  bed-h 0 [6 mm (bed-h)] measure-B pop pop

  0 0 measure-A pop pop
  0 bed-w [-6 mm (bed-w)] measure-B pop pop

  flush-measures

  % endswitch trigger thing: slots in the sled.
  /finger-len 3 mm def
  /endswitch-len
     bed-drive-pos acrylic-t add end-switch-thick sub
     drive-mount-pos end-switch-thick add
     sub def
  end-switch-from-back-of-sled
  bed-w 2 div end-switch-offset add acrylic-t 2 div sub moveto
  endswitch-len 0 slot-rlineto
  stroke

  end-switch-from-back-of-sled
  bed-w 2 div end-switch-offset add measure-A pop pop
  end-switch-from-back-of-sled bed-w [-30 mm] measure-B pop pop
  flush-measures

  /finger-len 6 mm def

  0 bed-w 2 div measure-A pop pop
  bed-drive-pos bed-w 2 div [-40 mm (bed-drive-pos)] measure-B pop pop
  flush-measures

  % slots on sled for drive train.
  gsave
    bed-drive-pos bed-drive-screw-w 2 div sub
    bed-w 2 div bed-drive-w 2 div sub moveto
    0 bed-drive-w slot-rlineto stroke
  grestore

  gsave
    bed-drive-pos bed-drive-screw-w 2 div add acrylic-t add
    bed-w 2 div bed-drive-w 2 div sub moveto
    0 bed-drive-w slot-rlineto stroke
  grestore

  % drive holder. this should be a separate sub-part
  gsave
   bed-h cut-dist add acrylic-t add 0 translate
   subpart-drive-holder flush-measures
   bed-drive-h cut-dist add 6 mm add 0 translate
   subpart-drive-holder clear-measures
   stroke
  grestore

  % Moving part holding the nut
  gsave
   bed-h acrylic-t add cut-dist add bed-drive-w cut-dist add translate

   % nut holder. That should be a separate sub-part.
   bed-drive-wobble 0 moveto
   bed-drive-h bed-drive-wobble sub bed-drive-w measure-box 2 mm rounded-corner-box
   flush-measures

   % Placing the nut.
   gsave
     % The nut is a polygon that we need to turn a little. So move to the center
     % and rotate our canvas.
     bed-drive-screw-top bed-drive-w 2 div translate
     0 0 moveto 360 12 div rotate inner-cut 6 bed-drive-screw-r n-polygon stroke
   grestore
  grestore

  % Endswitch trigger block, plugged into the sled.
  gsave
     /finger-len 3 mm def
     bed-h acrylic-t add 30 mm add cut-dist add bed-drive-w cut-dist add translate
     newpath
     15 mm 0 moveto
     0 endswitch-len finger-rlineto-noscrew
     -15 mm 0 rlineto
     0 0 lineto
     15 mm 0 lineto stroke
  grestore

  % since this is fluorescent material, cut out the hsync collector here.
  gsave
     % more fudging with moving to a free space...
     bed-h 30 mm add cut-dist 2 mul add    bed-w 20 mm sub translate
     0 0 moveto hsync-len hsync-w box
     0 hsync-w cut-dist add moveto hsync-len hsync-w box
     % ... do it a couple of times, as some will fall through the cracks :)
     0 hsync-w cut-dist add 2 mul moveto hsync-len hsync-w box
     0 hsync-w cut-dist add 3 mul moveto hsync-len hsync-w box
     stroke
  grestore
  end
} def

% base for the inner parts that hold motor and bearing.
/subpart-drivetrain-base {
    2 dict begin
    0 0 moveto  current-measure-A
    /finger-len drive-train-fingers def
    /width bed-w acrylic-t 2 mul sub def
    width 0 finger-rlineto-noscrew [-6 mm] current-measure-B

    /finger-len 5 mm def
    0 stepper-height finger-rlineto-noscrew
    width neg 0 rlineto
    0 stepper-height neg finger-rlineto-noscrew
    stroke

    % Endswitch
    width 2 div end-switch-offset add
    stepper-height 15 mm sub moveto current-measure-A
    end-switch stroke
    bed-w acrylic-t sub stepper-height 15 mm sub [-10 mm ] measure-B pop pop flush-measures
    end
} def

/part-motor-holder {
   (Motor) 5 mm 5 mm describe
    1 dict begin
    /width bed-w acrylic-t 2 mul sub def
    subpart-drivetrain-base
    width 2 div stepper-height sub stepper-height 2 div 5 mm circle stroke %cable
    gsave
    inner-cut
    width 2 div stepper-height 2 div translate
    0 0 stepper-center-plate-dia 2 div circle stroke
    stepper-mount-screw stepper-mount-screw stepper-screw-dia 2 div circle stroke
    stepper-mount-screw neg stepper-mount-screw stepper-screw-dia 2 div circle stroke
    stepper-mount-screw neg stepper-mount-screw neg stepper-screw-dia 2 div circle stroke
    stepper-mount-screw stepper-mount-screw neg stepper-screw-dia 2 div circle stroke
    grestore
    end
} def

/part-bearing-holder {
   (Bearing) 10 mm 5 mm describe
    1 dict begin
    /width bed-w acrylic-t 2 mul sub def
    subpart-drivetrain-base
    width 2 div stepper-height 2 div acme-dia 2 div circle stroke

    width 2 div end-switch-offset add 8 mm add
    stepper-height 2 div 4 mm add 2.5 mm circle stroke %cable
    end
} def

/part-bottom {
  (Bottom) 40 mm 10 mm describe
  acrylic-t neg acrylic-t neg moveto
  inner-device-len acrylic-t 2 mul add bed-w acrylic-t 2 mul add measure-box box

  1 dict begin
  /finger-len 15 mm def

  0 0 moveto inner-device-len 0 slot-rlineto stroke  % lower part
  inner-device-len bed-w moveto inner-device-len neg 0 slot-rlineto stroke

  /finger-len drive-train-fingers def
  % mounting for motor
  drive-mount-pos bed-w moveto
  0 bed-w neg slot-rlineto stroke

  0 bed-w 2 div measure-A pop pop
  drive-mount-pos bed-w 2 div [20 mm (drive-mount-pos)] measure-B pop pop

  % mouting for bearing
  bearing-mount-pos bed-w moveto
  0 bed-w neg slot-rlineto stroke

  0 bed-w 2 div measure-A pop pop
  bearing-mount-pos bed-w 2 div [-20 mm (bearing-mount-pos)] measure-B pop pop

  % finger holes to better access side screws
  true {
    22 mm acrylic-t 2 mul add 8 mm slide-holes stroke
    gsave 0 bed-w translate -22 mm acrylic-t 2 mul sub 8 mm slide-holes stroke grestore
  } if
  end
  flush-measures
} def

%% Assembly

acrylic-t cut-dist add cut-dist translate

print-bottom {
  0 acrylic-t translate   % to have space for the fingers
  part-bottom
  0 bed-w acrylic-t add cut-dist add translate
} if

print-bottom-drivetrain {
  0 acrylic-t translate   % to have space for the fingers
  part-motor-holder
  gsave bed-w acrylic-t 2 mul add cut-dist add 0 translate part-bearing-holder grestore
  0 28.2 mm cut-dist add translate
} if

print-slide-rail-bottom {
  (Slide Rail Bottom) 50 mm 8 mm describe
  part-slide-rail-bottom
  0 bed-slide-high-bottom cut-dist add translate part-slide-rail-bottom
  0 bed-slide-high-bottom cut-dist add translate
} if

print-sled {
  part-sled
  0 bed-w cut-dist 2 mul add translate
} if

print-slide-rail-top {
  part-slide-rail-top
  0 bed-slide-high-top cut-dist add translate part-slide-rail-top
  0 bed-slide-high-top cut-dist add translate
} if

print-sidepanels {
  % Two side-panels, turned around and printed in place
  part-sidepanel flush-measures
  gsave inner-device-len side-cut-distance translate 180 rotate part-sidepanel
  clear-measures grestore
  % move up
  0 side-cut-distance cut-dist add translate
} if

print-front-back {
  0 0 moveto part-front stroke % front-piece
  gsave bed-w acrylic-t 2 mul add cut-dist add 0 translate
        part-back stroke grestore % back piece
  0 inner-device-high down-mirror-high add mirror-holder-r add cut-dist add translate
} if

print-toppanel {
  0 acrylic-t translate   % to have space for the fingers
  0 0 moveto part-toppanel

  true {
     % extra raiser board for the mirror
    gsave
    inner-device-len 10 mm sub 49 mm translate
    true  % cut outline
    0 0 rot-mirror-footprint stroke
    grestore
  } if
  0 bed-w 2 acrylic-t mul add translate
} if

print-pcbframe {
  gsave
  0 bed-w acrylic-t sub 1 mm add translate -90 rotate
  part-pcbframe
  % extra raiser board for the mirror. Use empty space in the area in the
  % middle. Since that often needs to be a thinner shim, this is perfect
  % as this is typically printed on 1mm
  70 mm 90 mm translate
  true  % cut outline
  0 0 rot-mirror-footprint stroke
  grestore
  0 bed-w acrylic-t 2 mul sub cut-dist add translate
} if

print-TEST-finger-slot {
    0 acrylic-t cut-dist add translate
    1 dict begin

    /Helvetica-Bold findfont 3 mm scalefont setfont
    engraving-cut
    5 mm 16 mm moveto (Slot Sample) show
    12 mm 32 mm moveto (10 mm) show
    8 mm 1 mm moveto (5 mm) show
    outer-cut

    outer-cut
    /finger-len 5 mm def
    0 0 moveto
    55 mm 0 groove-rlineto-noscrew
    0 35 mm rlineto

    /finger-len 10 mm def
    -55 mm 0 groove-rlineto
    0 -35 mm rlineto
    stroke

    0 0 moveto
    /finger-len 5 mm def
    0 10 mm rmoveto
    55 mm 0 slot-rlineto

    0 0 moveto
    /finger-len 10 mm def
    0 20 mm rmoveto
    55 mm 0 slot-rlineto

    33 mm 29 mm photo-diode-cutout
    10 mm 29 mm moveto hsync-slot

    % Finger sample
    /Helvetica-Bold findfont 3 mm scalefont setfont
    engraving-cut 65 mm 12 mm moveto (Finger Sample) show outer-cut

    60 mm 0 moveto
    /finger-len 10 mm def
    55 mm 0 finger-rlineto
    0 20 mm rlineto
    /finger-len 5 mm def
    -55 mm 0 finger-rlineto-noscrew
    0 -20 mm rlineto
    stroke
    end
} if

stroke
showpage
